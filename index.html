<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Virtual Screen Detector</title>
  <style>
    :root { --bg:#0b0d10; --panel:#14181d; --muted:#9aa7b1; --text:#e6edf3; --accent:#6ea8fe; --ok:#2ecc71; --warn:#f39c12; --bad:#e74c3c; }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#0b0d10,#0e1116 40%,#0b0d10);color:var(--text);font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
    .wrap{max-width:1100px;margin:0 auto;padding:24px}
    h1{margin:6px 0 10px}
    .sub{color:var(--muted);margin-bottom:16px}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    .card{background:var(--panel);border:1px solid #222a33;border-radius:16px;padding:16px;box-shadow:0 10px 40px rgba(0,0,0,.35);margin-bottom:16px}
    .btn{appearance:none;border:1px solid #2a3440;background:#161b22;color:var(--text);padding:10px 14px;border-radius:12px;font-weight:600;cursor:pointer;transition:.2s}
    .btn:hover{transform:translateY(-1px);border-color:#3a4656}
    .btn.primary{background:linear-gradient(180deg,#1f6feb,#1158c7);border-color:#1f6feb}
    .badge{display:inline-block;padding:4px 10px;border-radius:999px;font-size:12px;font-weight:700;letter-spacing:.2px}
    .b-ok{background:rgba(46,204,113,.15);color:var(--ok);border:1px solid rgba(46,204,113,.35)}
    .b-warn{background:rgba(243,156,18,.15);color:var(--warn);border:1px solid rgba(243,156,18,.35)}
    .b-bad{background:rgba(231,76,60,.15);color:var(--bad);border:1px solid rgba(231,76,60,.35)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace; font-size:13px}
    table{width:100%;border-collapse:collapse}
    th,td{padding:8px 10px;border-bottom:1px solid #232a33;vertical-align:top}
    th{color:#b7c2cc;text-align:left;font-weight:700;width:240px}
    textarea{width:100%;min-height:220px;resize:vertical;background:#0d1117;color:var(--text);border:1px solid #222a33;border-radius:12px;padding:12px}
    .muted{color:var(--muted)}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="row" style="justify-content:space-between;align-items:flex-start">
        <div>
          <h1>Virtual Screen Detector</h1>
          <div class="sub">Эвристическая проверка «виртуальное/без-GPU окружение» vs «физическое» на стороне браузера.</div>
        </div>
        <div class="row">
          <button class="btn primary" id="runBtn">Запустить проверку</button>
          <button class="btn" id="copyBtn" disabled>Скопировать JSON</button>
          <button class="btn" id="saveBtn" disabled>Скачать JSON</button>
        </div>
      </div>
      <div class="row" style="justify-content:space-between;margin-top:8px">
        <div class="mono" id="summaryPill">Готов к запуску…</div>
        <span class="badge" id="badge">—</span>
      </div>
    </div>

    <div class="card">
      <h3>Итоги и причины</h3>
      <div id="hints" class="mono muted">Нажмите «Запустить проверку», чтобы увидеть детали.</div>
    </div>

    <div class="card">
      <h3>Параметры окружения</h3>
      <table>
        <tbody id="envT"></tbody>
      </table>
    </div>

    <div class="card">
      <h3>Графика (WebGL/WebGL2)</h3>
      <table>
        <tbody id="gfxT"></tbody>
      </table>
    </div>

    <div class="card">
      <h3>Полный отчёт (JSON)</h3>
      <textarea id="jsonOut" readonly class="mono" placeholder="Нажмите «Запустить проверку»"></textarea>
      <div class="muted" style="margin-top:8px">
        Подсказка: в Chrome откройте <code>chrome://gpu</code> — строки «Hardware accelerated» означают, что GPU используется.
      </div>
    </div>
  </div>

<script>
const $ = s => document.querySelector(s);
const fmt = v => (v===undefined||v===null? '—' : (typeof v==='object'? JSON.stringify(v): String(v)));

function glInfo(kind="webgl"){
  try{
    const c = document.createElement("canvas");
    const gl = c.getContext(kind);
    if(!gl) return {supported:false};
    const dbg = gl.getExtension("WEBGL_debug_renderer_info");
    const vendor = dbg ? gl.getParameter(dbg.UNMASKED_VENDOR_WEBGL) : gl.getParameter(gl.VENDOR);
    const renderer = dbg ? gl.getParameter(dbg.UNMASKED_RENDERER_WEBGL) : gl.getParameter(gl.RENDERER);
    const maxTex = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    const maxCube = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
    const ext = gl.getSupportedExtensions() || [];
    return {supported:true, vendor, renderer, maxTextureSize:maxTex, maxCubeMapSize:maxCube, extensionsCount: ext.length};
  }catch(e){return {supported:false, error:String(e)}}
}

async function runDetection(){
  // Screen / Window / Navigator
  const screenInfo = {
    width: screen.width, height: screen.height,
    availWidth: screen.availWidth, availHeight: screen.availHeight,
    colorDepth: screen.colorDepth, pixelDepth: screen.pixelDepth,
    devicePixelRatio: window.devicePixelRatio,
    innerWidth, innerHeight, outerWidth, outerHeight,
    orientation: screen.orientation?.type || null,
  };
  const navInfo = {
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    languages: navigator.languages,
    hardwareConcurrency: navigator.hardwareConcurrency,
    maxTouchPoints: navigator.maxTouchPoints,
    webdriver: navigator.webdriver === true
  };

  // WebGL/WebGL2
  const webgl  = glInfo("webgl");
  const webgl2 = glInfo("webgl2");

  // WebGPU (только индикатор)
  const webgpu = { supported: 'gpu' in navigator };
  if(webgpu.supported){
    try{
      const adapter = await navigator.gpu.requestAdapter();
      if(adapter){ webgpu.adapterName = adapter.name || null; }
    }catch(e){ webgpu.error = String(e); }
  }

  // Media devices
  const mediaDevices = { supported: !!(navigator.mediaDevices?.enumerateDevices) };
  if(mediaDevices.supported){
    try{
      const list = await navigator.mediaDevices.enumerateDevices();
      mediaDevices.count = list.length;
      mediaDevices.kinds = Array.from(new Set(list.map(d=>d.kind)));
    }catch(e){ mediaDevices.error = String(e); }
  }

  // Permissions snapshot
  async function queryPerm(name){
    try{ const p = await navigator.permissions.query({name}); return p.state; }
    catch{ return 'unsupported'; }
  }
  const permissions = {
    camera: await queryPerm('camera'),
    microphone: await queryPerm('microphone'),
    geolocation: await queryPerm('geolocation'),
    notifications: await queryPerm('notifications'),
  };

  // Heuristics
  const hints = [];
  const webglSoftware =
    /(llvmpipe|software|swiftshader)/i.test((webgl.renderer||'')) ||
    /(software)/i.test((webgl.vendor||'')) ||
    /(llvmpipe|software|swiftshader)/i.test((webgl2.renderer||'')) ||
    /(software)/i.test((webgl2.vendor||''));

  if (webgl.suggested || webgl2.suggested) {} // placeholder, не используется

  // Информативные, но НЕ «красные» сами по себе
  if (/linux/i.test(navInfo.platform||'')) {
    hints.push("Инфо: Linux-платформа — нормальная ситуация для DPR=1 без масштабирования.");
  }

  // Причины (информативные)
  if (webglSoftware) hints.push("WebGL/WebGL2 выглядят как программный рендер (llvmpipe/Software/SwiftShader).");
  if (mediaDevices.supported && (mediaDevices.count===0)) hints.push("enumerateDevices вернул 0 устройств (камер/микрофонов).");
  if (navInfo.webdriver) hints.push("navigator.webdriver === true (признак автоматизации).");
  if (/headless/i.test(navInfo.userAgent||'')) hints.push("User-Agent содержит 'Headless'.");

  // Более «жёсткая» логика: считаем подозрительным, если есть софт-рендер И (нет устройств ИЛИ webdriver/headless)
  const strongContext = (mediaDevices.count===0) || navInfo.webdriver || /headless/i.test(navInfo.userAgent||'');
  const suspicionStrong = webglSoftware && strongContext;

  // Общая оценка
  const suspicious = suspicionStrong;

  const report = {
    screenInfo, navInfo, webgl, webgl2, webgpu, mediaDevices, permissions,
    heuristics: {
      webglSoftware,
      strongContext,
      suspicionStrong,
      suspicionScore: [webglSoftware, strongContext].filter(Boolean).length
    },
    suspectVirtual: suspicious,
    note: "Ложные срабатывания возможны при отключённом аппаратном ускорении, старых драйверах или запуске через удалённые сессии."
  };

  render(report, hints);
  return report;
}

function render(rep, hints){
  // Summary line
  const pill = $('#summaryPill');
  const badge = $('#badge');

  const txt = rep.suspectVirtual
    ? '⚠ Обнаружены признаки виртуального/без-GPU окружения'
    : (rep.heuristics.webglSoftware
        ? 'ℹ Обнаружен программный рендер, но контекст слабый'
        : '✓ Похоже на физическое окружение / GPU доступен');

  pill.textContent = `${txt} · score=${rep.heuristics.suspicionScore}`;
  badge.className = 'badge ' + (rep.suspectVirtual ? 'b-bad' : (rep.heuristics.webglSoftware ? 'b-warn' : 'b-ok'));
  badge.textContent = rep.suspectVirtual ? 'Подозрительно' : (rep.heuristics.webglSoftware ? 'Нейтрально' : 'Ок');

  // Hints list
  $('#hints').innerHTML = hints.length
    ? `<ul>${hints.map(h=>`<li>${h}</li>`).join('')}</ul>`
    : '<span class="muted">Подозрительных признаков не найдено.</span>';

  // Environment table
  const env = {
    userAgent: rep.navInfo.userAgent,
    platform: rep.navInfo.platform,
    languages: rep.navInfo.languages,
    hardwareConcurrency: rep.navInfo.hardwareConcurrency,
    maxTouchPoints: rep.navInfo.maxTouchPoints,
    webdriver: rep.navInfo.webdriver,
    screen: `${rep.screenInfo.width}×${rep.screenInfo.height} @ DPR=${rep.screenInfo.devicePixelRatio}`,
    inner: `${rep.screenInfo.innerWidth}×${rep.screenInfo.innerHeight}`,
    outer: `${rep.screenInfo.outerWidth}×${rep.screenInfo.outerHeight}`,
    avail: `${rep.screenInfo.availWidth}×${rep.screenInfo.availHeight}`,
    orientation: rep.screenInfo.orientation
  };
  fillTable($('#envT'), env);

  // Graphics table
  const gfx = {
    webgl_supported: rep.webgl.supported,
    webgl_vendor: rep.webgl.vendor || 'n/a',
    webgl_renderer: rep.webgl.renderer || 'n/a',
    webgl_maxTexture: rep.webgl.maxTextureSize ?? 'n/a',
    webgl_extensions: rep.webgl.extensionsCount ?? 'n/a',
    webgl2_supported: rep.webgl2.supported,
    webgl2_vendor: rep.webgl2.vendor || 'n/a',
    webgl2_renderer: rep.webgl2.renderer || 'n/a',
    webgl2_maxTexture: rep.webgl2.maxTextureSize ?? 'n/a',
    webgl2_extensions: rep.webgl2.extensionsCount ?? 'n/a',
    webgpu_supported: rep.webgpu.supported,
    webgpu_adapter: rep.webgpu.adapterName || rep.webgpu.error || 'n/a',
    media_devices_supported: rep.mediaDevices.supported,
    media_devices_count: rep.mediaDevices.count ?? 'n/a',
    media_kinds: rep.mediaDevices.kinds || 'n/a'
  };
  fillTable($('#gfxT'), gfx);

  // JSON
  const json = JSON.stringify(rep, null, 2);
  $('#jsonOut').value = json;
  $('#copyBtn').disabled = false;
  $('#saveBtn').disabled = false;
}

function fillTable(tbody, obj){
  tbody.innerHTML = '';
  Object.entries(obj).forEach(([k,v])=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<th>${k}</th><td class="mono">${fmt(v)}</td>`;
    tbody.appendChild(tr);
  });
}

// Actions
$('#runBtn').addEventListener('click', async ()=>{
  $('#runBtn').disabled = true; $('#runBtn').textContent = 'Проверяю…';
  try{ await runDetection(); } finally {
    $('#runBtn').disabled = false; $('#runBtn').textContent = 'Запустить проверку';
  }
});
$('#copyBtn').addEventListener('click', async ()=>{
  try{
    await navigator.clipboard.writeText($('#jsonOut').value);
    $('#copyBtn').textContent = 'Скопировано!';
    setTimeout(()=> $('#copyBtn').textContent = 'Скопировать JSON', 1000);
  }catch{}
});
$('#saveBtn').addEventListener('click', ()=>{
  const blob = new Blob([$('#jsonOut').value], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'virtual_screen_report.json';
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=> URL.revokeObjectURL(a.href), 2000);
});
</script>


<script>
navigator.mediaDevices.enumerateDevices().then(devs => console.log("devices:", devs)).catch(e => console.error("enum error:", e));
Promise.all([
  navigator.permissions.query({name:'camera'}).catch(()=>null),
  navigator.permissions.query({name:'microphone'}).catch(()=>null),
]).then(p => console.log("permissions:", p));
</script>


<script>
// reality-check.js
(async () => {
  const out = {
    when: new Date().toISOString(),
    ua: navigator.userAgent,
    platform: navigator.platform,
    languages: navigator.languages,
    timezoneOffset: new Date().getTimezoneOffset(),
    locale: Intl.DateTimeFormat().resolvedOptions().locale,
    hw: {
      dpr: window.devicePixelRatio || 0,
      screen: { w: screen.width, h: screen.height, aw: screen.availWidth, ah: screen.availHeight, colorDepth: screen.colorDepth },
      cores: navigator.hardwareConcurrency ?? null,
      deviceMemory: navigator.deviceMemory ?? null,
      touchPoints: navigator.maxTouchPoints ?? 0
    },
    nav: {
      plugins: (navigator.plugins && Array.from(navigator.plugins).map(p => p.name)) || [],
      mimeTypes: (navigator.mimeTypes && Array.from(navigator.mimeTypes).map(m => m.type)) || [],
      webdriver: navigator.webdriver === true
    },
    permissions: {},
    webrtc: { candidates: [], hasRTCPeerConnection: !!window.RTCPeerConnection },
    mediaDevices: { kinds: {}, total: 0 },
    webgl: {},
    canvasHash: null,
    fontsProbe: {}
  };

  // ----- Canvas fingerprint (без внешних изображений, поэтому не tainted)
  try {
    const c = document.createElement('canvas');
    c.width = 280; c.height = 80;
    const ctx = c.getContext('2d');
    ctx.textBaseline = 'top';
    ctx.font = "14px 'Arial'";
    ctx.fillStyle = '#f60';
    ctx.fillRect(125,1,62,20);
    ctx.fillStyle = '#069';
    ctx.fillText('RealityCheck-' + (navigator.hardwareConcurrency||'x'), 2, 2);
    ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
    ctx.fillText('𝕋𝕖𝕤𝕥', 4, 18);
    const dataUrl = c.toDataURL('image/png');
    // быстрый poor-man hash
    let hash = 0;
    for (let i = 0; i < dataUrl.length; i++) {
      hash = ((hash<<5) - hash) + dataUrl.charCodeAt(i);
      hash |= 0;
    }
    out.canvasHash = hash >>> 0; // uint
  } catch (e) { out.canvasHash = null; }

  // ----- WebGL (в т.ч. UNMASKED_VENDOR/RENDERER)
  function getParamSafe(gl, pname) { try { return gl.getParameter(pname); } catch { return null; } }
  (function webgl() {
    const canvas = document.createElement('canvas');
    let gl = canvas.getContext('webgl2') || canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl) { out.webgl = { supported:false }; return; }
    const dbg = gl.getExtension('WEBGL_debug_renderer_info');
    out.webgl = {
      supported: true,
      version: gl instanceof WebGL2RenderingContext ? 'webgl2' : 'webgl1',
      vendor: String(getParamSafe(gl, gl.VENDOR)),
      renderer: String(getParamSafe(gl, gl.RENDERER)),
      shading: String(getParamSafe(gl, gl.SHADING_LANGUAGE_VERSION)),
      maxTextureSize: Number(getParamSafe(gl, gl.MAX_TEXTURE_SIZE)),
      unmaskedVendor: dbg ? String(getParamSafe(gl, dbg.UNMASKED_VENDOR_WEBGL)) : null,
      unmaskedRenderer: dbg ? String(getParamSafe(gl, dbg.UNMASKED_RENDERER_WEBGL)) : null
    };
  })();

  // ----- enumerateDevices (включая audiooutput)
  try {
    if (navigator.mediaDevices?.enumerateDevices) {
      const list = await navigator.mediaDevices.enumerateDevices();
      out.mediaDevices.total = list.length;
      const kinds = {};
      for (const d of list) kinds[d.kind] = (kinds[d.kind] || 0) + 1;
      out.mediaDevices.kinds = kinds; // e.g. {audioinput:1, audiooutput:1, videoinput:1}
    }
  } catch (e) {}

  // ----- Permissions (camera/microphone/notifications)
  async function perm(name) {
    try {
      if (!navigator.permissions?.query) return 'unknown';
      const s = await navigator.permissions.query({ name });
      return s.state; // 'prompt'|'granted'|'denied'
    } catch { return 'unknown'; }
  }
  out.permissions.camera = await perm('camera');
  out.permissions.microphone = await perm('microphone');
  out.permissions.notifications = await perm('notifications');

  // ----- WebRTC ICE candidates (выдаёт типы: host/srflx/relay)
  try {
    if ('RTCPeerConnection' in window) {
      const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
      pc.createDataChannel('x');
      pc.onicecandidate = ev => {
        if (ev.candidate && ev.candidate.candidate) {
          const c = ev.candidate.candidate;
          const m = c.match(/ typ (\w+) /);
          if (m) out.webrtc.candidates.push(m[1]); // host, srflx, relay
        }
      };
      const off = await pc.createOffer({ offerToReceiveAudio: false, offerToReceiveVideo: false });
      await pc.setLocalDescription(off);
      await new Promise(r => setTimeout(r, 800));
      pc.close();
    }
  } catch (e) {}

  // ----- CSS font probe (очень поверхностно)
  (function fontProbe() {
    const test = (font) => {
      const s = document.createElement('span');
      s.style.cssText = 'position:absolute;left:-9999px;font-size:72px;';
      s.innerHTML = 'mmmmmmmmmmlli';
      document.body.appendChild(s);
      s.style.fontFamily = font + ', monospace';
      const w = s.getBoundingClientRect().width;
      s.remove();
      return Math.round(w);
    };
    out.fontsProbe.sample = {
      Arial: test('Arial'),
      'Times New Roman': test('Times New Roman'),
      'Courier New': test('Courier New')
    };
  })();

  // ----- Простейший «скор реальности»
  function scoreReality(o) {
    let score = 0, reasons = [];

    // WebGL renderer
    const r = (o.webgl.unmaskedRenderer || o.webgl.renderer || '').toLowerCase();
    const v = (o.webgl.unmaskedVendor || o.webgl.vendor || '').toLowerCase();
    const BAD = ['llvmpipe','software','swiftshader','microsoft basic render','virtualbox','vmware','parallels'];
    if (BAD.some(k => r.includes(k) || v.includes(k))) { reasons.push('software/virtual GPU'); }
    else score += 25;

    // DPR & screen
    if (o.hw.dpr >= 1 && o.hw.dpr <= 4 && o.hw.screen.w >= 1024 && o.hw.screen.h >= 768) score += 10;
    else reasons.push('odd DPR/screen');

    // Hardware threads & memory
    if ((o.hw.cores ?? 0) >= 2) score += 10; else reasons.push('low cores');
    if ((o.hw.deviceMemory ?? 2) >= 2) score += 5;

    // Plugins & mimeTypes (в реальных Chrome/Firefox обычно не пусто)
    if (o.nav.plugins.length + o.nav.mimeTypes.length > 0) score += 10;
    else reasons.push('no plugins/mimeTypes');

    // enumerateDevices
    const md = o.mediaDevices.kinds;
    if ((md.audioinput||0) + (md.videoinput||0) + (md.audiooutput||0) >= 1) score += 15;
    else reasons.push('no media devices');

    // WebRTC
    if (o.webrtc.candidates.length > 0) score += 5;

    // Canvas hash present
    if (o.canvasHash !== null) score += 10; else reasons.push('canvas blocked');

    // Permissions states
    if (['granted','prompt'].includes(o.permissions.camera) || ['granted','prompt'].includes(o.permissions.microphone)) score += 10;

    // webdriver flag
    if (o.nav.webdriver) reasons.push('navigator.webdriver=true'); else score += 10;

    return { score: Math.min(score, 100), reasons };
  }

  const verdict = scoreReality(out);

  console.log('=== Reality Check ===');
  console.table({
    'UA': out.ua,
    'Platform': out.platform,
    'DPR': out.hw.dpr,
    'Screen': `${out.hw.screen.w}x${out.hw.screen.h} (${out.hw.screen.colorDepth}bit)`,
    'Cores': out.hw.cores,
    'DeviceMemory(GB)': out.hw.deviceMemory,
    'Plugins': out.nav.plugins.length,
    'MimeTypes': out.nav.mimeTypes.length,
    'MediaDevices': JSON.stringify(out.mediaDevices.kinds),
    'WebGL Vendor': out.webgl.unmaskedVendor || out.webgl.vendor,
    'WebGL Renderer': out.webgl.unmaskedRenderer || out.webgl.renderer,
    'MaxTexture': out.webgl.maxTextureSize,
    'WebRTC types': out.webrtc.candidates.join(',') || 'none',
    'CanvasHash': out.canvasHash,
    'webdriver': out.nav.webdriver
  });
  console.log('Permissions:', out.permissions);
  console.log('Fonts probe (widths):', out.fontsProbe.sample);
  console.log('Reality score (0..100):', verdict.score, '— issues:', verdict.reasons);
  return { details: out, verdict };
})();

</script>
</body>
</html>
